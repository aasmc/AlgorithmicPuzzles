разборы задач спринта by Славец

# задача А:

поддерживаем стек из блоков (товар, количество)

плюс поддерживаем словарь <товар - общее количество>

помните, что суммарное количество товаров одного типа может вылазить за 32-битный тип

# задача B:

отсортируем задачи по возрастанию старта

будем поддерживать параллельно всех работников

для каждой новой задачи мы будем выбирать работника, у которого последняя задача закончилась раньше всех

если мы можем выдать работнику текущую задачу - выдаем

иначе нанимаем нового работника

поддерживать последние задачи работников можно в Priority Queue

# задача С:

напишем динамическое программирование

dp[index][first] = second

"second - минимальное время, когда второй курьер закончит выполнять свои заказы, если обработали заказы 1..index и первый курьер закончил выполнять свои заказы во время first"

ответом будет min(max(first, dp[n][first])) по всем возможным first

# задача D:

допустим, что мы знаем радиус стола

построим граф, где вершинами будут
- левая и правая стенки коридора
- колонны

ребро между вершинами будет только в том случае, если между вершинами НЕЛЬЗЯ пронести круглую кровать

в таком случае кровать НЕЛЬЗЯ пронести по коридору, если существует путь от левой стенки до правой стенки по ребрам, которые я выше описал (подумайте почему)

заметим, что если мы можем пронести кровать с радиусом R, то и с радиусом < R можем

аналогично, если не можем с R, то и с > R не можем

получаем бинпоиск по радиусу, внутри которого проверяем связность между левой и правой стенками (dfs / bfs)

# задача E:

построим граф, где вершины - это тройки (x, y, dir)

- x, y - координаты клетки
- dir - в какую сторону смотрит трактор (8 направлений движения + начальное состояние "вверх колесами")

ребра будут двух типов:

- ребро из (x, y, dir) в (x + dx[dir], y + dy[dir], dir) стоимостью 0 (просто едем в том же направлении)
- ребро из (x, y, dir) в (x, y, other_dir) стоимостью 1 (поворот)

теперь ваша задача - от состояния (sx, sy, вверх колесами) добраться до состояния (ex, ey, любой dir) за минимальную стоимость

это решается через 0-1 bfs:
- если вы встречаете ребро весом 1, то кладете в конец очереди
- если ребро весом 0, то кладете в начало очереди

единственное - ваша вершина может оказаться в очереди дважды с разными расстояниями, надо обрабатывать вершину из очереди только один раз